# AWS SAM - Monorepo TypeScript Backend With Yarn & Webpack

This repository shows how to build & deploy a Typescript backend monorepo using AWS SAM, Yarn & Webpack.

The objectives :

- Each function has its own package with its own code
- No dependency at all in the packages thanks to Webpack & Lambda Layers so we can reduce the artifacts size
- Share code between functions to avoid repeating ourself

## Prerequisites

### AWS SAM

The AWS Serverless Application Model (SAM) is an open-source framework for building serverless applications. It provides shorthand syntax to express functions, APIs, databases, and event source mappings. With just a few lines of configuration, you can define the application you want and model it.

- https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html
- https://github.com/aws/serverless-application-model
- https://github.com/aws/aws-sam-cli

Currently, SAM does not support natively & efficiently monorepo TypeScript applications. This is why I created this repository.

### NodeJS

Node.js is an open-source, cross-platform, back-end, JavaScript runtime environment that executes JavaScript code outside a web browser.

- https://nodejs.org/en/

We will be using NodeJS 12.x as it is the latest version supported by AWS at the moment.

### Yarn

Yarn is a package manager for your code. It allows you to use and share code with other developers from around the world. Yarn does this quickly, securely, and reliably so you don't ever have to worry.

- https://yarnpkg.com/

Yarn is used instead of NPM as it has better support in local dependencies management.

### Webpack

At its core, webpack is a static module bundler for modern JavaScript applications. When webpack processes your application, it internally builds a dependency graph which maps every module your project needs and generates one or more bundles.

- https://webpack.js.org/

## Folder hierarchy

```
.
├── .aws-sam                          # SAM artifacts folder
├── build                             # Build folder
    ├── package.json                  # Dependencies for build like typescript, jest, webpack, types, ...
    ├── tsconfig.json                 # TypeScript configuration
├── functions                         # Functions folder
    ├── hello-function                # Hello function folder
        ├── src                       # Source code for hello function
        ├── dist                      # JavaScript files generated by Webpack
        ├── package.json              # No dependency, only required by SAM
    ├── goodbye-function              # Goodbye function folder
        ├── src                       # Source code for goodbye function
        ├── dist                      # JavaScript files generated by Webpack
        ├── package.json              # No dependency, only required by SAM
    ├── dist                          # JavaScript files generated by TypeScript Compiler
    ├── package.json                  # Local dependencies only (paths to build & layers dependencies)
    ├── tsconfig.json                 # TypeScript configuration (extending the one in build folder)
    ├── webpack.config.js             # Webpack configuration
├── layers                            # Layers folder
    ├── global-layers                 # Global layers folder
        ├── aws-global-layer          # AWS global layer folder
            ├── package.json          # Dependencies like aws-sdk
        ├── common-global-layer       # Common global layer folder
            ├── package.json          # Common dependencies like source-map, shared code
    ├── function-layers               # Functions layers folder
        ├── hello-function-layer      # Hello function layer folder
            ├── package.json          # Specific dependencies for the hello function layer if any
        ├── goodbye-function-layer    # Goodbye function layer folder
            ├── package.json          # Specific dependencies for the goodbye function layer if any
├── shared                            # Shared code folder
    ├── src                           # Source for shared code
    ├── dist                          # JavaScript files generated by TypeScript Compiler
    ├── package.json                  # Dependencies for shared
    ├── tsconfig.json                 # TypeScript configuration (extending the one in build folder)
├── package.json
├── template.yml
```

## How it works

All the configuration is dispatched into three folders :

- `build` folder
- `shared` folder
- `layers` folder
- `functions` folder

### The build folder

This folder contains all the configuration needed to build the code.

The `package.json` contains the required dependencies :

```
{
  "name": "@aws-sam-typescript-webpack-backend/build",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": "^12"
  },
  "dependencies": {
    "@types/aws-lambda": "^8.10.64",
    "@types/fs-extra": "^9.0.3",
    "@types/jest": "^26.0.15",
    "@types/node": "^14.14.2",
    "@types/pino": "^6.3.3",
    "@types/webpack-node-externals": "^2.5.0",
    "fs-extra": "^9.0.1",
    "jest": "^26.6.1",
    "ts-jest": "^26.4.2",
    "ts-loader": "^8.0.6",
    "ts-node": "^9.0.0",
    "typescript": "^4.0.3",
    "webpack": "^5.2.0",
    "webpack-cli": "^4.1.0",
    "webpack-node-externals": "^2.5.2"
  }
}
```

And the `tsconfig.json` contains the TypeScript configuration to compile the source code :

```
{
  "compilerOptions": {
    "target": "es2019",
    "module": "commonjs",
    "inlineSourceMap": true,
    "lib": ["es2019"],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitReturns": true,
    "removeComments": true,
    "skipLibCheck": true
  }
}
```

These files will be used by `shared` and `functions` folders.

### The shared folder

This folder contains all the code you want to share across your functions. When you build the project, it will generate a TypeScript declaration file and you will be able to import it in your functions under the scope `@aws-sam-typescript-webpack-backend/shared`.

To illustrate this, I added a `logger.ts` file to share logging (using `pino`).

### The layers folder

This folder contains all the layers :

- Global layers
- Function layers

Two global layers are setup here. One for the AWS SDK dependencies and one for the common dependencies (that contains the shared code as well).

```
{
  "name": "@aws-sam-typescript-webpack-backend/aws-global-layer",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": "^12"
  },
  "dependencies": {
    "aws-sdk": "^2.778.0",
    "aws-xray-sdk": "^3.2.0"
  }
}
```

```
{
  "name": "@aws-sam-typescript-webpack-backend/common-global-layer",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": "^12"
  },
  "scripts": {
    "clean": "rm -rf node_modules dist",
    "build": "mkdir -p dist && rsync -avr ../../../shared dist --exclude node_modules --exclude src && yarn install"
  },
  "dependencies": {
    "source-map-support": "^0.5.19",
    "@aws-sam-typescript-webpack-backend/shared": "file:./dist/shared"
  },
  "files": [
    "dist"
  ]
}
```

Note the `build` script that is copying the files from `shared` folder and the dependency referencing this copy instead of the local path. This is due to a known issue in SAM. See https://github.com/aws/aws-sam-cli/issues/2064 for more details.

The function layers are present to show that you can add some dependencies only for a specific function. But if it is used by multiple functions, it is easier and better to put it in the common global layer.

Using layers this way, we can remove all the functions dependencies and minimize the package size. To know more about layers, see https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html

### The functions folder

This folder contains all the functions :

- Hello function
- Goodbye function

SAM requires the `CodeUri` to be a path that contains a `package.json` file. Following this convention involves to setup a `package.json` for each function and to duplicate the configuration. We can avoid this by setting a `package.json` in the functions root folder (we don't care about dependencies because we will use Webpack tree shaking feature).

```
{
  "name": "@aws-sam-typescript-webpack-backend/functions",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": "^12"
  },
  "scripts": {
    "clean": "rm -rf node_modules dist */dist",
    "build": "yarn install && yarn tsc",
    "bundle": "yarn install && yarn webpack"
  },
  "dependencies": {
    "@aws-sam-typescript-webpack-backend/aws-global-layer": "file:../layers/global-layers/aws-global-layer",
    "@aws-sam-typescript-webpack-backend/common-global-layer": "file:../layers/global-layers/common-global-layer",
    "@aws-sam-typescript-webpack-backend/hello-function-layer": "file:../layers/function-layers/hello-function-layer",
    "@aws-sam-typescript-webpack-backend/goodbye-function-layer": "file:../layers/function-layers/goodbye-function-layer"
  },
  "devDependencies": {
    "@aws-sam-typescript-webpack-backend/build": "file:../build"
  }
}
```

```
{
  "name": "@aws-sam-typescript-webpack-backend/hello-function",
  "description": "Empty package.json (required by SAM) as packaging is handled at the functions root folder with webpack",
  "version": "1.0.0",
  "private": true,
  "files": [
    "dist"
  ]
}
```

```
{
  "name": "@aws-sam-typescript-webpack-backend/goodbye-function",
  "description": "Empty package.json (required by SAM) as packaging is handled at the functions root folder with webpack",
  "version": "1.0.0",
  "private": true,
  "files": [
    "dist"
  ]
}
```

Note the `dist` folder. This will tell NPM to include it in the package generated by `sam build`. This is mandatory as this is the folder where Webpack will generate the `js` files.

We also need to add a `tsconfig.json` file in the functions root folder to tells TypeScript how to build the functions :

```
{
  "extends": "../build/tsconfig.json",
  "compilerOptions": {
    "rootDir": "./",
    "outDir": "./dist"
  },
  "include": ["./*-function/src/*.ts"]
}
```

And the last one is the `webpack.config.ts` configuration file :

```
import { Configuration, Entry } from 'webpack';

import fs from 'fs-extra';
import webpackNodeExternals from 'webpack-node-externals';

const apps: Entry = {};
fs.readdirSync('./')
  .filter((file) => file.endsWith('-function'))
  .forEach(function (app) {
    console.log(app + ' found !');
    apps[app] = './' + app + '/src/app.ts';
  });

const config: Configuration = {
  mode: 'production',
  target: 'node',
  devtool: 'source-map',

  externals: [webpackNodeExternals()],

  entry: apps,

  output: {
    filename: '[name]/dist/app.js',
    path: __dirname,
    libraryTarget: 'commonjs',
  },

  resolve: {
    extensions: ['.ts', '.js'],
  },

  module: {
    rules: [
      {
        test: /\.ts/,
        use: 'ts-loader',
      },
    ],
  },
};

export default config;
```

This configuration will do the tree shaking for each function and will put the generated `js` files in the `dist` folder.

`webpack-node-externals` is used to make sure that all dependencies are not included (as they are in the layers).

## How to use

From the root folder use the following commands :

- `yarn clean` to remove all generated files and folders
- `yarn build` to build the application with TypeScript
- `yarn bundle` to bundle the application with Webpack
- `yarn deploy` to deploy the application with SAM
